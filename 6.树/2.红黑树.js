/*
二插搜索树有一个缺点：但如果插入的是有序或者逆序的数据，二叉树就是非平衡的了，排在一条线上，
其实就变成了一个链表，它的快速查找、插入和删除指定数据项的能力就丧失了

红黑树就是解决了上述缺点的平衡树

红黑树的基础是二插搜索树

红黑树的特征：
性质1：每个节点要么是红色，要么是黑色
性质2：根节点是黑色
性质3：每个叶子节点都是黑色的空节点（NIL节点）
性质4：每个红色节点的两个子节点一定都是黑色节点
性质5：任一节点到每个叶子节点的路径都包含相同数量的黑色节点

根据性质得出的推论：
推论1：根据性质4，红黑树中不会出现两个红色节点相邻的情况
推论2：树中最短可能出现的路径，为都是黑色节点的路径
推论3：树中最长可能出现的路径，为红色节点和黑色节点交替出现的路径
推论4：根据性质5以及推论2、3，树中没有一条路径会比其他路径长出2倍
*/

const RED = "red";
const BLACK = "black";

function Node(key) {
    this.left = null;
    this.right = null;
    this.key = key;
    this.rbColor = RED; //新节点初始时默认为红色
}

function RedBlackTree(params) {
    this.root = null;
}

/*
设要插入的节点为N，父节点为P，祖父节点为G，父亲的兄弟节点为U

情况1:
当插入第一个数据时，没有根节点，新节点N位于树的根上，没有父节点P
直接将红色变为黑色即可，这样满足性质2

情况2：
新节点的父节点P是黑色，
直接插入新节点，没有任何问题

情况3：
父节点P为红色，U也为红色，那么祖父节点G一定为黑色
父红叔红祖黑  => 变为  父黑叔黑祖红

上面三种情况无需考虑是插入到父节点的左边还是右边

情况4.1：插入的节点N是父节点的左节点，且父节点P为红色，U为黑色，祖父G为黑色

父P变为黑
祖G变为红
绕祖父G进行右旋

情况5.1：插入的节点N是父节点的右节点，且父节点P为红色，U为黑色，祖父G为黑色

以父P进行左旋 
然后将P作为新插入的黑色节点考虑，也就是回到情况4.1


上述情况四和情况五是以插入节点的父亲节点是祖父节点的左子节点进行考虑的
还有插入节点的父亲节点是祖父节点的右子节点没考虑，只需要把旋转时的方向变化

情况4.2：插入的节点N是父节点的右节点，且父节点P为红色，U为黑色，祖父G为黑色

父P变为黑
祖G变为红
绕祖父G进行左旋

情况5.2：插入的节点N是父节点的左节点，且父节点P为红色，U为黑色，祖父G为黑色
以父P进行右旋 
然后将P作为新插入的黑色节点考虑，也就是回到情况4.2
*/
// 插入操作
RedBlackTree.prototype.insert = function (key) {
    let newNode = new Node(key);
    if (this.root === null) {
        this.root = node;
        node.rbColor = BLACK;
    } else {
        let current = this.root;
        let p = null;
        while (current) {
            g = p;
            p = current;
            if (newNode.key < current.left) {
                current = current.left;
            } else if (newNode.key > current.left) {
                current = current.right;
            }
        }
    }
};
